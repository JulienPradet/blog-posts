Pour le premier élément de la boucle, on demande d'accéder au DOM et de récupérer la largeur du bouton en cours. Dès qu'on l'a, on met à jour le style du bouton. Cependant, ce qu'il est important de noter, c'est qu'en faisant cela, on n'a pas encore mis à jour la page côté client. On a juste précisé qu'il fallait mettre à jour la largeur.

On a fini de traiter notre premier élément, on passe au second. On demande donc la largeur du deuxième bouton. Le problème, c'est que le navigateur sait que depuis son dernier *Layout*, une donnée du style a changé (la largeur du premier bouton). Ainsi, pour ne pas mentir, il va déclencher un nouveau *Layout* pour être sûr que la largeur du deuxième bouton soit toujours bonne. Alors seulement, il envoie la valeur. Une fois que c'est fait, on décide de mettre à jour la largeur du deuxième bouton. Et donc lors du passage sur le troisième élément de la boucle, on aura à nouveau une phase de *Layout*.

On appelle ça le *Layout Thrashing*&nbsp;: on redemande constamment le *Layout* alors que le premier nous suffit.

En quoi est-ce important pour faire des animations performantes ? Ca l'est parce que pour déterminer comment animer notre contenu, on va régulièrement avoir besoin d'intérroger le DOM, notamment en début d'animation. Or, pour que l'utilisateur ne percoivent pas de délais dans le démarrage d'une animation, il faut réussir à tout préparer en seulement 100ms-150ms. Et si on recalcule trop souvent le *Layout*, ces 100ms peuvent rapidement être dépassées.

Sur l'exemple suivant, vous pouvez voir que l'animation saute au début (c'est d'autant plus flagrant sur mobile). C'est parce qu'on a dépassé le budget de 150ms. Vous pouvez l'identifier dans vos DevTools dès lors que la partie concernant le layout (en violet) fait concurrence à celle concernant le JavaScript (en jaune) dans la répartition des temps de calcul.
