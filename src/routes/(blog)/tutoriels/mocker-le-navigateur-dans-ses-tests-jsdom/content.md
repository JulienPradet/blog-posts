Dans [un tutoriel pr√©c√©dent](/tutoriels/testing-library-comment-rediger-des-tests-en-react/) nous avons vu comment faire des tests unitaires en JavaScript. Pour cela nous sommes pass√©s par [jsdom](https://github.com/jsdom/jsdom) : une impl√©mentation d'une grande partie des APIs navigateurs en Node.js.

L'int√©r√™t de cette librairie est que nous pouvons ex√©cuter de la manipulation de DOM alors que nous ne sommes pas dans un vrai navigateur. Nous avons donc l'opportunit√© d'ex√©cuter plus rapidement un bon nombre de tests pour aller chercher les cas limites et s√©curiser nos composants.

Le probl√®me c'est que tout n'est pas disponible : nous ne sommes pas dans un navigateur donc tout ce qui est visuel ne sera pas testable. A titre d'exemple, des APIs telles que `getBoundingClientRect`, `scrollTo`, `IntersectionObserver`, `matchMedia`, etc. ne sont pas impl√©ment√©es dans jsdom puisqu'elles reposent sur la taille de votre navigateur, un √©l√©ment purement visuel.

Vous vous retrouvez avec des erreurs du style :

```
TypeError: window.matchMedia is not a function
```

Que doit-on faire dans ce cas l√† ? Doit-on nous aussi faire une fausse impl√©mentation (= un mock) ? O√π se trouve la limite de ce qu'on peut remplacer ?

## Quel genre d'API peut-on mocker ?

Prenons l'exemple d'un composant qui doit afficher des choses en fonction du device de l'utilisateur (ajouter une classe, changer du contenu, etc. sur mobile vs desktop).

Pour cela il y a deux impl√©mentations possibles :

- ajouter un [event listener sur le `resize`](https://developer.mozilla.org/en-US/docs/Web/API/Window/resize_event)
  ```js
  window.addEventListener('resize', (event) => {
  	console.log(window.innerWidth);
  });
  ```
- utiliser [`window.matchMedia`](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia) qui permet de r√©utiliser la syntaxe des media queries en CSS pour savoir si on match ou non un certain type de device.
  ```js
  const match = window.matchMedia('(min-width: 992px)');
  match.addListener(() => {
  	console.log(match.matches); // true or false
  });
  ```

Dans le premier cas, il va √™tre tr√®s difficile de mocker de mani√®re convaincante le `resize` : quand une personne resize votre page, iel ne va pas d√©clencher un unique √©v√©nement de `resize`. Il y aura certainement un changement d'orientation, voire d√©placer sa souris qui va d√©clencher plein d'√©v√©nements : autant d'√©v√©nements qu'il faudra aussi simuler et mocker. Il faudra aussi √™tre vigilant √† bien mettre √† jour la taille de la fen√™tre, mettre √† jour les informations de l'√©l√©ment en mockant le getBoundingClientRect, etc.

Ce ne sera donc pas le genre d'API qu'il sera pertinent de mocker parce que votre test sera 90% de mock pour 10% de test. De plus, cela risque de n'√™tre qu'une repr√©sentation tr√®s partielle du comportement r√©el du navigateur. Sur ce genre de cas, privil√©giez donc des tests e2e avec [Cypress](https://www.cypress.io/) ou [Playwright](https://playwright.dev/).

Pour le deuxi√®me cas, celui de `window.matchMedia` c'est diff√©rent : on ne va plus devoir simuler la totalit√© des `resize`, on peut se contenter de d√©clencher un √©v√©nement unique dans lequel `match.matches === true`.

Si on g√©n√©ralise :

- ‚úÖ mockez si vous pouvez vous contenter d'une quantit√© limit√©e de mock ou d'√©v√©nements
- ‚ùå ne pas mocker si vous vous retrouvez avec une multitude de mocks √† cr√©er ou que vous commencez √† trop d√©pendre de positions ou de tailles en pixels.

D'ailleurs de mani√®re g√©n√©rale, quelque chose qui est facile √† mocker sera certainement un code qui sera meilleur. Typiquement il est pr√©conis√© de passer par `matchMedia` plut√¥t que `resize` parce que c'est plus performant, plus fiable et plus expressif. Que du bonheur :)

### Que faire quand j'utilise une librairie qui abstrait le navigateur ?

Maintenant admettons que vous utilisez par exemple [use-match-media](https://github.com/jepser/use-match-media), un hook React qui g√®re pour vous `window.matchMedia` : que faire ?

Est-ce que vous devez mocker la librairie en elle m√™me ou `window.matchMedia` qui est en dessous ?

Ca d√©pend. üòÅ

Personnellement je suis d'avis que plus vous mockez quelque chose de bas niveau, mieux c'est. En effet, cela vous permet d'√™tre plus r√©silient au changement et de tester une plus grande partie de la couche. Par exemple, si vous changez de version majeure de `use-match-media`, vous serez content¬∑e de ne pas avoir besoin d'adapter votre mock ET d'avoir un test qui vous assure que la fonctionnalit√© compl√®te fonctionne. Si vous aviez mock√© la librairie vous allez devoir v√©rifier manuellement que la librairie vous renvoie toujours les bonnes informations et vous devrez faire √©voluer votre mock le cas √©ch√©ant. Il est donc plus pertinent de mocker `window.matchMedia` plut√¥t que la librairie qui l'utilise.

Cependant parfois cela peut rendre vos mocks trop complexes. Ca peut √™tre le cas par exemple pour tout ce qui va toucher au r√©seau. Il peut par exemple √™tre plus facile de mocker le hook `useQuery` de [@tanstack/react-query](https://tanstack.com/query/latest) plut√¥t que d'aller mocker le `window.fetch` qui est en dessous. Ou peut √™tre en passant par [msw](https://mswjs.io/) comme le propose Kent C. Dodds dans [Stop mocking fetch](https://kentcdodds.com/blog/stop-mocking-fetch).

## Cas pratique de `matchMedia`

Maintenant que nous savons s'il est pertinent de se lancer dans un mock, voyons comment nous pourrions impl√©menter ce mock.

1. Remplacer l'API navigateur dans le test
2. D√©clencher un listener manuellement

### Remplacer l'API navigateur

Quand on utilise un `window.matchMedia`, le code ressemble √† ceci :

```js
// addClassOnMobile.js
function addClassOnMobile() {
	const match = window.matchMedia('(min-width: 992px)');
	// initialize mobile class when the function is first called
	document.body.classList.toggle('mobile', match.matches);

	// update the mobile class whenever the device format changes
	match.addListener((match) => {
		document.body.classList.toggle('mobile', match.matches);
	});
}
```

Nous avons donc une fonction qui prend en param√®tre une `mediaQuery`. Cette fonction retourne un objet qui a les cl√©s :

- `matches` qui indique si √† l'initialisation on v√©rifie cette mediaQuery ou non
- `addListener` qui est appel√© lorsqu'il y a un changement d'affichage

En r√©alit√© l'objet est de type [`MediaQueryList`](https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList) et donc a plus de cl√©s disponibles. Cependant, si dans votre code vous n'utilisez que `matches` et `addListener` n'allez pas vous emb√™ter √† mocker les autres.

Ainsi, si on retranscrit ces mots avec du code, √ßa nous donnerait :

```js
// matchMediaMock.js
export const matchMediaMock = (mediaQuery) => {
	let callbacks = [];

	return {
		matches: false,
		addListener: (callback) => {
			callbacks.push(callback);
		}
	};
};
```

Ce n'est qu'une premi√®re impl√©mentation partielle, mais √ßa nous suffit pour commencer √† remplacer l'API dans notre test :

```js
// addClassOnMobile.test.js
beforeEach(() => {
	window.matchMedia = matchMediaMock;
});

afterEach(() => {
	// Par acquis de conscience on nettoie toujours les variables
	// globales qu'on a modifi√© au cours de notre test
	// afin d'√©viter fuites de m√©moire et pollution des autres tests
	window.matchMedia = undefined;
});
```

Maintenant si on execute notre test, ce ne sera plus l'API du navigateur ou de jsdom mais bien le n√¥tre qui sera utilis√©.

> üí° Parfois, l'API que vous voulez mocker existe d√©j√†. Dans ce cas, vous avez deux options :
>
> - soit vous pouvez utiliser jest.spyOn afin d'observer l'interaction avec cette API
> - soit vous pouvez conserver la m√™me m√©thode que pr√©c√©demment mais en passant √† r√©initialiser dans `afterEach` non pas avec `undefined` mais avec la valeur initialze
>
>   ```js
>   let initialMatchMedia;
>
>   beforeEach(() => {
>   	initialMatchMedia = window.matchMedia;
>   	window.matchMedia = matchMediaMock;
>   });
>
>   afterEach(() => {
>   	window.matchMedia = initialMatchMedia;
>   });
>   ```

### D√©clencher un listener manuellement

Cependant, on ne d√©clenche pour l'instant jamais de mise √† jour. Le callback pass√© au `addListener` n'est jamais appel√©, il est uniquement stock√© dans le tableau `callbacks`.

Si on se r√©f√®re √† la m√©thode **Given When Then** que j'avais pr√©sent√© dans [Testing Library : Comment r√©diger des tests front-end ?](https://www.julienpradet.fr/tutoriels/testing-library-comment-rediger-des-tests-en-react/), il nous manque le **When** :
quand le navigateur change de format et d√©clenche le listener.

```js
// addClassOnMobile.test.js
it('should add a mobile class to the body when the match changes', () => {
	// GIVEN
	addClassOnMobile();

	// WHEN
	triggerMediaChange(true);

	// THEN
	expect(document.body.classList.contains('mobile')).toBe(true);
});
```

La m√©thode `triggerMediaChange` n'existe nul part pour le moment. Nous allons devoir la cr√©er pour pour nous assurer que les listeners soient bien d√©clench√©s quand elle est appel√©e.

Le principe d'un mock est qu'il doit fonctionner, certes, mais dans le cas tr√®s restreint de votre cas. Ainsi, m√™me si dans notre premi√®re impl√©mentation du `matchMediaMock` nous avions stock√© les callback √† l'int√©rieur du mock, il ne faut pas h√©siter √† les d√©placer pour r√©pondre √† notre besoin, m√™me quand √ßa para√Æt moche.

```diff
// matchMediaMock.js
+let callbacks = [];

export const matchMediaMock = (mediaQuery) => {
-   let callbacks = [];

	return {
		matches: false,
		addListener: (callback) => {
			callbacks.push(callback);
		}
	};
};

+export const triggerMediaChange(matches) {
+    callbacks.forEach((callback) => {
+        callback({
+            matches: matches
+        })
+    })
+}
```

Ici, nous avons fait en sorte que _tous_ les listeners de _tous_ les matchMedia en cours d'utilisation soient appel√©s avec `{matches: true}` dans le cas o√π on appelle `triggerMediaChange(true)`.

C'est donc une impl√©mentation **tr√®s** limit√©e, mais dans notre cas nous n'avons qu'un seul `matchMedia` √† la fois. Nous n'avons pas besoin d'aller plus loin.

Si au contraire nous avions deux ex√©cutions diff√©rentes (un `matchMedia` pour la vue mobile et un `matchMedia` pour la vue tablette), nous aurions certainement besoin d'am√©liorer notre mock. Mais pour l'instant cette version suffira.

Si vous √™tes arriv√©s jusqu'ici, vous avez s√ªrement votre test qui passe au vert. üéâ

Cependant, avant de passer la suite je veux retenir votre attention sur un point : quand vous √©crivez des mocks, il y a des grandes chances de s'emm√™ler les pinceaux. En effet, on impl√©mente une version simplifi√©e de la r√©alit√© qui, par essence, est fausse. Il y a donc de fortes chances pour que le mock ne fasse pas r√©ellement ce que vous imaginez **ou** que votre test emp√™che des r√©gressions sur votre mock au lieu d'emp√™cher des r√©gressions sur votre code.

Pensez donc √† casser votre code (ce qu'il y a dans `addClassOnMobile.js`), pour vous assurer que votre test d√©tectera toute r√©gression. **Tant que vous n'aurez jamais vu votre test √©chouer (rouge), vous pouvez consid√©rer que votre test ne marche pas.** Je ne compte plus le nombre de fois o√π je pensais avoir fini d'√©crire mes tests mais o√π je me suis rendu compte que je ne testais rien. C'est d'ailleurs un des avantages du <abbr tabIndex="-1" title="Test Driven Development">TDD</abbr> : vu que vous n'avez pas encore cod√© au moment d'√©crire vos tests, vous le verrez forc√©ment rouge.

### Penser √† nettoyer son mock apr√®s les tests

C'est toujours un bon r√©flexe √† prendre d'essayer de se demander : que se passe-t-il si j'effectue un autre test ?

Dans notre cas, on fait appel pendant le test √† `addClassOnMobile`. Cette fonction appelle `matchMedia` (la version mock√©e) qui ajoute un nouveau callback dans le tableau `callbacks`. Cette derni√®re existe √† l'√©chelle du module (= une fonction qui n'est pas cach√©e dans une fonction). Donc si un autre test fait un appel √† `matchMedia`, on ne se retrouvera avec **deux** listeners dans notre tableau `callbacks`.

Cela peut vite commencer √† provoquer des probl√®mes notamment quand plusieurs fichiers diff√©rents utilisent le m√™me mock. Donc √† la fin de chaque test on va faire attention √† bien nettoyer notre mock.

```js
// addClassOnMobile.test.js
import { cleanupMatchMedia } from './matchMediaMock';

afterEach(() => {
	cleanupMatchMedia();
});
```

```js
// matchMediaMock.js

export const cleanupMatchMedia = () => {
	callbacks = [];
};
```

### Exercice : ajouter un test avec une valeur initiale diff√©rente

Si on r√©capitule √† quoi ressemble notre mock, notre ficher ressemble √† ceci :

```js
// matchMediaMock.js

/** @var {((match: {matches: boolean}) => void)[]} */
let callbacks = [];

/**
 * @param {string} mediaQuery
 */
export const matchMediaMock = (mediaQuery) => {
	return {
		matches: false,
		addListener: (callback) => {
			callbacks.push(callback);
		}
	};
};

/**
 * @param {boolean} matches
 */
export const triggerMediaChange(matches) {
    callbacks.forEach((callback) => {
        callback({
            matches: matches
        })
    })
}

export const cleanupMatchMedia = () => {
	callbacks = [];
};
```

Cependant, admettons qu'on veut ajouter un nouveau test :

- it should add a mobile class on body when the initial media matches

Actuellement, dans `matchMediaMock`, on retourne `matches: false`. Ce n'est pas compatible avec le test qu'on veut ajouter : il faudrait que `matches: true`. Comment pourrions-nous faire ?

> üí° Je vous encourage √† chercher la solution par vous m√™me avant de passer √† la suite. Une piste serait d'imaginer ce qu'on pourrait faire dans l'√©tape **Given** du test pour influencer le comportement du mock.

<figure>
<img src="/images/posts/testing-library/interlude.gif" alt="Le texte 'A little interlude' est affich√© sur un fond √©toil√© tout mignon.">
<figcaption>Source : <a href="https://giphy.com/gifs/break-pause-interlude-x2Cqbgx3SSCNNghso8">KerBop Publishing</a></figcaption>
</figure>

**‚ÑπÔ∏è Solution ‚ÑπÔ∏è**

L'astuce est de d√©clencher le changement d'√©tat **avant** l'appel √† `addClassOnMobile`. D'un point de vue navigateur c'est ce qui se passe : au tout premier affichage de la page, il se demande sur quel type de device on est.

```diff
// addClassOnMobile.test.js
it('should add a mobile class on body when the initial media matches', () => {
+   triggerMediaChange(true);
	addClassOnMobile();

-   triggerMediaChange(true);

	expect(document.body.classList.contains('mobile')).toBe(true);
});
```

Par contre, pour que √ßa fonctionne il faut n√©cessairement faire √©voluer le mock. Ainsi, au lieu de renvoyer un `matches: false`, on va le variabiliser. Quand on appelle `triggerMediaChange`, on change cette variable. Ainsi, au moment o√π notre code va appeler `matchMediaMock`, il aura la valeur du dernier appel √† `triggerMediaChange`.

```diff
// matchMediaMock.js

let callbacks = [];
+let currentMatches = false;

export const matchMediaMock = (mediaQuery) => {
	return {
-		matches: false,
+		matches: currentMatches,
		addListener: (callback) => {
			callbacks.push(callback);
		}
	};
};

export const triggerMediaChange = (matches) => {
+	currentMatches = matches;
	callbacks.forEach((callback) => {
		callback({
			matches: matches
		});
	});
};

export const cleanupMatchMedia = () => {
+	currentMatches = false;
	callbacks = [];
};
```

Et enfin, comme pour les callbacks, on pense bien √† r√©initialiser la variable initiale histoire d'√™tre s√ªr d'√™tre exactement dans le m√™me √©tat √† chaque d√©marrage de test.

</details>

## R√©capitulatif

Nous voil√† arriv√© au bout ! üëè

Vous sentez-vous capable d'attaquer les mocks dont vous avez besoin dans vos tests maintenant ? N'h√©sitez pas √† me partager vos r√©ussites ou difficult√©s sur [Mastodon](https://piaille.fr/@julienpradet) ou [Twitter](https://twitter.com/JulienPradet).

En attendant, s'il n'y a que quelques √©l√©ments que je veux que vous reteniez de cet article, ce serait :

- ce n'est pas parce que jsdom n'impl√©mente pas une API qu'il n'est pas possible de la tester unitairement
- √©vitez cependant de mocker tout ce qui repose sur une orchestration complexe ou sur des pixels, les tests <abbr tabIndex="-1" title="End-To-End">e2e</abbr> ou les tests visuels seront plus adapt√©s
- les mocks reposent souvent sur des variables globales, pensez √† les nettoyer
- veillez √† toujours casser votre code quand vous avez fini d'√©crire votre test : tant que le test n'aura pas √©t√© rouge vous n'√™tes pas s√ªr que votre test est bon.

Si ce sont des pratiques que vous aimeriez propager au sein de votre entreprise, sans forc√©ment trop savoir par o√π commencer ou sans avoir le temps de vous y pencher, n'h√©sitez pas √† me contacter par [mail](mailto:julien.pradet+article-blog@gmail.com). Nous pourrons en discuter avec plaisir.

Adishatz üëã
